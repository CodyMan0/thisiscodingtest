## 동적계획법

동적계획법은 메모리 공간을 이용해 빠르게 문제를 해결하는 방법이다.
다음과 같은 조건을 가질 때, 사용할 수 있다.

1. 큰문제를 작은 문제로 나눌 수 있다. (최적부문)
2. 작은 문제에서 구한 정답은 그것을 포함하는 큰 문제에서도 동일하다.

### 적합한 예시, 피보나치 수열

피보나치 수열은 f(n)=f(n-1)+f(n-2),f(1)=f(2)=1로 표현될 수 있다.
프로그래밍으로 표현하기 위해선 재귀 함수를 사용하면 아래와 같이 표현할 수 있다.

```python
def fibo(x):
  if x==1 or x==2:
    return 1
  return fibo(x-1)+fibo(x-2)

print(fibo(3))
```

위의 방식으로만 계산할 경우, n이 커질수록 같은 계산을 반복하면서 O(2^N)의 시간복잡도를 가지게 된다. 왜냐하면 중복되는 계산이 많아지기 때문이다.

이를 해결위한 2가지 방법을 책에서 소개한다.

#### 1. 탑다운 방식(재귀 함수)

탑다운 방식은 큰문제를 풀기 위해 작은 문제를 호출하는 방식으로, "메모이제이션" (캐싱)을 이용해 계산결과를 저장해 다음 결과에 사용한다.
재귀함수를 사용해 계속해서 큰수에서 작은수로 작아져간다.

```python
# 계산 된 결과를 담을 리스트 초기화
d=[0]*100

# 탑 다운 dynamic programming으로 구현한 재귀
def fibo(x):
  # 기저 조건
  if x==1 or x==2:
    return 1
  # 이미 계산한 문제라면 그대로 반환
  if d[x]!=0:
    return d[x]
  # 아니라면 계산함.
  d[x]=fibo(x-1)+fibo(x-2)
  return d[x]

print(fibo(99))
```

이전에 이미 계산해둔 값을 불러오기만 하고 새롭게 구하는 값은 N이므로 O(N)의 시간복잡도로 빠르게 구할 수 있다.

일반적으로 재귀 함수로 구현한 다이내믹 프로그래밍보다 반복문을 이용한 다이나믹 프로그래밍이 성능이 더 좋다.

- 시간 복잡도 : O(N)

#### 2. 바텀업 방식(반복문)

바텀업 방식은 아래에서 위로 올라가는 방식으로, 반복문과 DP 테이블 (저장용 리스트)를 이용해 구현할 수 있다.

```python
d[1]=1
d[2]=1
n=99

for i in range(3,n+1):
  d[i]=d[i-1]+d[i-2]

print(d[n])

```

- 다이나믹 프로그래밍의 전형적인 형태는 반복문 형태.
- 특정한 문제를 완전 탐색 알고리즘으로 접근했을 때 시간이 오래 걸리면 다이나믹 프로그래밍을 적용할 수 있는지 고려해보면 된다.
- 파이썬에 sys 라이브러리에 포함되어있는 setrecursionlimit() 함수를 호출하면 재귀 제한을 완화할 수 있다.

## 관련있는 개념

1. 분할 정복 알고리즘 (퀵 정렬)

- 분할 정복 알고리즘과 다이나믹 프로그래밍의 차이는 다이나믹 프로그래밍은 문제들이 서로 영향을 미치고 있다는 것이다. 퀵 정렬에서는 피벗이 정해지면 피벗의 위치는 바뀌지 않는다.
